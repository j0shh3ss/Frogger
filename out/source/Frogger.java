/* autogenerated by Processing revision 1286 on 2022-11-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Frogger extends PApplet {

Frog frog;
Lane[] lanes;
int SAFETY = 0;
int CAR = 1;
int LOG = 2;
int lives = 3;
float grid = 50;
PImage img;
int level = 0;

//If reset game is added, might want to create frog else where at another time
 public void resetGame() {
  //creating frog, Frog(width location, height location)
  frog = new Frog(width/2-grid/2,height-grid,grid);
  frog.attach(null);
}

 public void gameOver() {
  background(0);
  fill(255);
  textAlign(CENTER,CENTER);
  text("Game Over..",width/2, height/2);
  fill(255);
  text("Click to play again",width/2, height/2+40);
  if(mousePressed){
     lives = 3;
     resetGame();
  }
}

//Fix the sizing of the win game hahahahahaha
 public void winGame(){
  background(255,255,0);
  fill(0);
  textAlign(CENTER,CENTER);
  text("You win!!!",width/2, height/2);
  fill(0);
  text("Click to play again",width/2,height/2+40);
//  text("Press any key to reset this level",width/2, height/2+40);
//  fill(0);
//  text("Or click the mouse to move onto level 2",width/2,height/2+60);
//  if(keyPressed){
//      lives = 3;
//      resetGame();
//   }
  if(mousePressed){
//    level++;
    resetGame();
  }
}

//Setting up the game
 public void setup() {
//size of game, make divisible by 50 for better results
  /* size commented out by preprocessor */;
  resetGame();
  textSize(20);
  img = loadImage("Frog.png");
  //number of lanes based on height
  int totalLanes = PApplet.parseInt(height/grid +1);
  lanes = new Lane[totalLanes];
  if(level == 0){
    loadLanesRound1();
  }
  // if(level == 1){
  //   loadLanesRound2();
  // }
}

 public void draw() {
  background(0);
  for(Lane lane : lanes) {
    lane.run();
  }
  int laneIndex = PApplet.parseInt(frog.y / grid);
  if(laneIndex > width || laneIndex > height){
    resetGame();
    lives--;
  }
  lanes[laneIndex].check(frog);
  if(laneIndex == 0){
   winGame();
  }
  if(lives <= 0){
    gameOver();
  }else{
    frog.show();
    frog.update();
  }
 // scores();
}

 public void scores(){
 fill(10);
 text("Lives: " + lives, width-80, height-35);
}

 public void loadLanesRound1(){
//Lane(index, what type, how many obs, width of obs * grid, space between obs, speed of obs, type again for color)
//for color lane
//LANE(index, color())
//for win lane
//Lane(index, number of obstacles covering, type to change the color of obs, color)
  lanes[0] = new Lane(0, 4, CAR);
  //logs
  lanes[1] = new Lane(1,LOG, 3,1,175,3,LOG);
  lanes[2] = new Lane(2,LOG, 4,1,200,-3,LOG);
  lanes[3] = new Lane(3,LOG, 3,2,225,4,LOG);
  lanes[4] = new Lane(4,LOG, 4,1,175,-2,LOG);
  //safety
  lanes[5] = new Lane(5, color(220,220,70));
  //road with cars
  lanes[6] = new Lane(6,CAR, 3,2,255,1,CAR);
  lanes[7] = new Lane(7,CAR, 2,1,150,-2,CAR);
  lanes[8] = new Lane(8,CAR, 2,3,350,3,CAR);
  lanes[9] = new Lane(9,CAR, 1,2,175,2,CAR);
  //start
  lanes[10] = new Lane(10, color(220,220,70));
  //lane so that they can't go below bottom row.
  lanes[11] = new Lane(11, color(0));
}

 public void loadLanesRound2(){
  /*
  Lane(index, what type, how many obs, width of obs * grid, space between obs, speed of obs, type again for color)
  for color lane
  LANE(index, color())
  for win lane
  Lane(index, number of obstacles covering, type to change the color of obs, color)
  */
  //Passed in log this time to match the color of the road
  lanes[0] = new Lane(0, 4, LOG);
  lanes[1] = new Lane(1,CAR, 3,1,175,3,CAR);
  lanes[2] = new Lane(2,CAR, 4,1,200,-3,CAR);
  lanes[3] = new Lane(3,CAR, 3,2,225,4,CAR);
  lanes[4] = new Lane(4,CAR, 4,1,175,-2,CAR);
  lanes[5] = new Lane(5, color(220,220,70));
  lanes[6] = new Lane(6,LOG, 3,2,255,1,LOG);
  lanes[7] = new Lane(7,LOG, 2,1,150,-2,LOG);
  lanes[8] = new Lane(8,LOG, 2,3,350,3,LOG);
  lanes[9] = new Lane(9,LOG, 1,2,175,2,LOG);
  lanes[10] = new Lane(10, color(220,220,70));
  lanes[11] = new Lane(11, color(0));
}

 public void keyPressed() {
  int laneIndex = PApplet.parseInt(frog.y / grid);
  if(laneIndex != 0){
    switch(keyCode) {
      //uses the move method in frog
      case UP: frog.move(0,-1);
        break;
      case DOWN: frog.move(0,1);
        break;
      case RIGHT: frog.move(1,0);
        break;
      case LEFT:  frog.move(-1,0);
        break;
    }
  }
}
class Frog extends Rectangle {
  Obstacle attached = null;
  Frog(float x, float y, float w) {
    super(x,y,w,w);
  }
  
   public void attach(Obstacle log) {
   attached = log; 
  }

   public void show() {
    tint(255,126);
    fill(255);
    image(img,x,y);
    rect(x,y,w,w);
  }
  
   public void update() {
    if (attached != null) {
     frog.x += attached.speed; 
    }
    frog.x = constrain(x,0,width-w);
    frog.x = constrain(x,0,width+w);
    frog.y = constrain(y,0,height-w);
    frog.y = constrain(y,0,height+w);
  }
  //This is the frog moving
   public void move(float xdir, float ydir) {
    x += xdir * grid;
    y += ydir * grid;
    frog.attach(null);
  }
}
class Lane extends Rectangle {
  Obstacle[] obstacles;
  int col;
  int type;
  
  //This is for the safe rows
  Lane(float index, int c) {
     super(0, index*grid, width, grid);
     type = SAFETY;
     obstacles = new Obstacle[0];
     col = c;
  }
  
  //This is for the end zone
  Lane(float index, int n, int t){
    super(0, index*grid, width,grid);
    obstacles = new Obstacle[n];
    type = t;
    float offset = 150;
    for(int i = 0; i < n; i++) {
       obstacles[i] = new Obstacle(offset * i, index*grid * i, grid + 25, grid, 0, 3); 
    }
    if(type == 1){
     col = color(3,0,64);
    }
    if(type == 2) {
      col = color(0);
    }
  }
  
 //Lane(height, what type, how many obs, width of obs * grid, space between obs, speed of obs) 
 //This is for the logs and cars
  Lane(float index, int t, int n, int len, float spacing, float speed, float col2){
   super(0, index*grid, width, grid);
   obstacles = new Obstacle[n];
   type = t;
   float offSet = random(0,200);
   for(int i = 0; i < n; i++) {
      obstacles[i] = new Obstacle(offSet + spacing * i, index*grid, grid*len, grid, speed, col2); 
   }
   if(type == 1){
     col = color(0);
   }
   else if(type == 2) {
    col = color(3,0,64); 
   }
  }
  
   public void check(Frog frog) {
    //checking if avoiding cars
    scores();
    if(type == CAR) {
       for(Obstacle o : obstacles) {
         if(frog.intersects(o)){
           resetGame();
           lives--;
         }
       }
       //checking if on log
     } else if(type == LOG) {
         boolean ok = false;
         for(Obstacle o : obstacles) {
          if(frog.intersects(o)) {
           ok = true;
           frog.attach(o);
          }
       }
       //if fall off log
       if(!ok){
        resetGame(); 
        lives--;
       }
     }
  }
  
   public void run() {
    fill(col);
    rect(x,y,w,h);
    for(Obstacle o : obstacles){
      o.show();
      o.update();
    }
  }
} 
class Obstacle extends Rectangle {
  float speed;
  float col;
  
  Obstacle(float x, float y, float w, float h, float s, float c){
    super(x,y,w,h);
    speed = s;
    col = c;
  }
  
   public void update() {
    x = x + speed;
    if(speed > 0 && x > width+grid) {
     x = -w-grid; 
    } else if (speed < 0 && x < -width-grid) {
      x = width+grid;
    }
  }
   public void show() {
    if(col == 1) {
      fill(140,0,210);
    }
    if(col == 2){
      fill(95,60,40);
    }
    if(col == 3){
      fill(15,57,28);
    }
    rect(x,y,w,h);
  }
}
class Rectangle {
  float x;
  float y;
  float w;
  float h;
  
  Rectangle(float x, float y, float w, float h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
   public boolean intersects(Rectangle other) {
    float left = x;
    float right = x + w;
    float top = y;
    float bottom = y + h;
    
    float oleft, oright,otop,obottom;
    oleft = other.x;
    oright = other.x + other.w;
    otop = other.y;
    obottom = other.y + other.h;
    
    return !(left >= oright || 
    right <= oleft || 
    top >= obottom ||
    bottom <= otop);
  }
}


  public void settings() { size(500, 550); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Frogger" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
